.386                  ; Указываем, что используем 32-битный режим
.model flat, stdcall  ; Плоская модель памяти, стандартный вызов
option casemap:none

.data
Res db 255 dup(0)     ; Резервируем место для результата (макс. длина 255)

.code
PadCh proc S: DWORD, C: BYTE, Len: BYTE
    ; Получаем длину строки S
    mov eax, [S]          ; Получаем адрес строки S
    movzx ecx, byte ptr [eax] ; Получаем длину строки S (первый байт)
    mov [Res], cl         ; Сохраняем длину в Res

    cmp cl, Len           ; Сравниваем длину S с Len
    jae StoreLen          ; Если S >= Len, переходим к StoreLen

    ; Заполняем строку символами C
    lea edi, [Res + 1]    ; Указатель на начало результата (после длины)
    lea esi, [eax + 1]    ; Указатель на первый символ строки S (пропускаем длину)
    mov edx, Len          ; Длина, которую нужно заполнить
    sub edx, cl           ; Остаток для заполнения

    ; Заполнение остатка символами C
FillLoop:
    mov [edi], C          ; Заполняем символом C
    inc edi               ; Переходим к следующему символу
    dec edx               ; Уменьшаем счетчик
    jnz FillLoop          ; Повторяем, пока есть символы для заполнения

StoreLen:
    ; Копируем строку S в результат
    lea esi, [eax + 1]    ; Указатель на первый символ строки S (пропускаем длину)
    mov ecx, [S]          ; Получаем длину строки S
    rep movsb             ; Копируем строку S в результат

    ret
PadCh endp

end
